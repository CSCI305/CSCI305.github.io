<center>

<hr>
<h1>Montana State University</h1>

<h2>CSCI 305 - Programming Languages</h2>

<h3>Midterm Exam</h3>

<h3>SPRING, 2018</h3>

<hr>

<h4>Name: <u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u><br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</h4>
<h4>Student Id: <u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u></h4>

<br/>

<table style="font-size:10pt" width="50%">
<thead>
 <td>Question</td>
 <td>Points</td>
 <td>Score</td>
</thead>
<tr>
 <td>1</td>
 <td>30</td>
 <td></td>
</tr>
<tr>
 <td>2</td>
 <td>2</td>
 <td></td>
</tr>
<tr>
 <td>3</td>
 <td>2</td>
 <td></td>
</tr>
<tr>
 <td>4</td>
 <td>2</td>
 <td></td>
</tr>
<tr>
 <td>5</td>
 <td>2</td>
 <td></td>
</tr>
<tr>
 <td>6</td>
 <td>2</td>
 <td></td>
</tr>
<tr>
 <td>7</td>
 <td>10</td>
 <td></td>
</tr>
<tr>
 <td>8</td>
 <td>15</td>
 <td></td>
</tr>
<tr>
 <td>9</td>
 <td>15</td>
 <td></td>
</tr>
<tr>
 <td>10</td>
 <td>20</td>
 <td></td>
</tr>
<tr>
 <td>Total:</td>
 <td>100</td>
 <td></td>
</tr>
</table>

</center>


(1) (30 points) Mark each question as either True (T) or False (F) by circling either T or F.

   a.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**T**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modula was one of the first languages to incorporate namespaces.

   b.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COBOL was designed as a programming language for scientific applications.

   c.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plankakul was originally developed for Artificial Intelligence problems.

   d.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A weakly typed programming language is one that detects all type errors at compile time.

   e.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A non-terminal that occurs on the far right of any production rule is right associative.

   f.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter coercion is not a type of simple polymorphism.

   g.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A language system involving the classical sequence typically has a step involving the loading of the source code into an interpreter.

   h.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ruby is a statically typed language.

   i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BNF is weaker in descriptive power than EBNF.

   j.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**T**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;There is no direct link between a rule's associativity and its precedence.

   k.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It is impossible to define a grammar which is inherently ambiguous.

   l.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overloading functions and operators can only be done in dynamically type languages because of their greater flexibility.

   m.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**T**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delayed linking, interpreters, and virtual machines are all features of language systems which deviate from the classical sequence.

   n.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**T**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A function exhibits parametric polymorphism if it has a type that contains one or more type variables.

   o.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ML allows for implicit type coercion.
<br/><br/><br/><br/><br/>
(2) (2 Points) Give the ML type corresponding to the following set: `{(true, true), (true, false), (false, true), (false, false)}`

  `(bool * bool) list`

<br/><br/><br/><br/><br/><br/><br/>
(3) (2 points) Context free grammars are used to capture which aspect of a programming language?

    B. Syntax

<br/>
(4) (2 points) Circle all of the following types that are primitive types:

    A. Java int

    B. ML String

    C. C float

    D. ML char
<br/>
(5) (2 points) Circle all of the following things that types are useful for:

    C. Both A and B

<br/>
(6) (2 points) Circle all of the following that are mainly Imperative Languages.

    A. C

    B. Fortran 77

    E. Perl
<br/>
(7) (10 points) What is the binding time for each of the following in a C/C++ program? State the binding time as precisely as possible (language-definition time, language-implementation time, compile time, link time, load time, or runtime)

        a. The meaning of the `while` keyword.
           Language Definition Time

        b. The location in memory of a local variable in a function.
           Run-time

        c. The type of a local variable in a function.
           Compile Time

<br/><br/>
(8) Answer these questions about the following grammar. The starting symbol is `<S>`

```
   <S> ::= <S1> + <S> | <S1>
   <S1> ::= <S2> | <S1> * <S2>
   <S2> ::= ( <S> ) | a | b
```

        a. (2 points) Which operator has higher precedence?

            The * operator

        b. (2 points) What is the associativity of the `*` operator?

            Left-Associative

        c. (2 points) Does this grammar describe a finite or infinite language?

            Infinite

        d. (2 points) Is this grammar ambiguous?

            No

        e. (4 points) Rewrite this grammar using EBNF, considering the version of EBNF
        provided in the book which adds only the grouping symbols `[ ]`, `{ }`, and
        `( )`.

          ```
          <S> ::= <S1> [+ <S>]
          <S1> ::= [<S1> *] <S2>
          <S2> ::= '(' <S> ')' | a | b
          ```

          OR

          ```
          <S> ::= <S1> [+ <S>]
          <S1> ::= <S2> {* <S2>}
          <S2> ::= '(' <S> ')' | a | b

          Note: <proda> ::= <prodb> {op <prodb>} is only for left-associative
          ```

          OR

          ```
          <S> ::= {<S1> +} <S1>
          <S1> ::= [<S1> *] <S2>
          <S2> ::= '(' <S> ')' | a | b

          Note: <proda> ::= {<prodb> op} <prodb> is for right-associative op
          ```

        f. (3 points) Draw a parse tree to explain the string: `b + a * (a + b) + a`

                          <S>
                           |
              ---------------------------
              |            |            |
             <S1>          +           <S>
              |                         |
              |                    ---------------------
              |                    |    |              |
             <S2>                 <S1>  +             <S>
              |                    |                   |
              |             ----------------           |
              |             |      |       |           |
              b           <S1>     *      <S2>        <S1>
                            |              |           |
                            |          ---------       |
                          <S2>         |   |   |       |
                            |          (  <S>  )      <S2>
                            a              |           |
                                       ---------       |
                                       |   |   |       |
                                      <S1> +  <S>      a
                                       |       |
                                      <S2>    <S1>
                                       |       |
                                       a      <S2>
                                               |
                                               b


(9) Suppose there are three variables X, Y, and Z with these types:
```
   X: integer that is divisible by 3
   Y: integer that is divisible by 12
   Z: integer
```

For each of the following assignments, knowing nothing about the values of the variables except their types, answer whether a language system can tell before running the program whether the assignment is safe? Answer Yes or No and explain why.

        a. (5 points) `Z := X`

           Yes, since the set of integers divisible by 3 is a subset of all integers the assignment is safe

        b. (5 points) `Y := Y + 1`

           No, since adding 1 to Y excludes it from the set of integers divisible by 12 and thus it cannot be assigned to Y.

        c. (5 points) `X := X + 3`

           Yes, since any integers in the set X plus 3 is still within the set of X and thus can be assigned to X.

(10) Consider an unknown language with a right-associative `*` operator that is overloaded to have the following types: `int * real -> real`, `int * int -> int`, `real*int -> real`, and `real*real -> real`. Suppose the variable `i` has type `int` and the variable `r` has type `real`. For each `*` operator in each of the following expressions, say which type of `*` is used:

        a. (5 points) `r * i`

             `real * int -> real`

        b. (5 points) `r * i * r`

             `r * i: real * int -> real`

             `i * r: real * real -> real`

        c. (5 points) `r * (i * r)`

             `(i * r): int * real -> real`

             `r * (): real * real -> real`

        d. (5 points) `i * r * i * (i * r)`

             `(i * r): int * real -> real`

             `i * r: int * real -> real`

             `r * i: real * real -> real`

             `i * (): int * real -> real`

<center>

<hr>
<h1>Montana State University</h1>

<h2>CSCI 305 - Programming Languages</h2>

<h3>Midterm Exam - Solutions</h3>

<h3>SPRING, 2018</h3>

<hr>

<h4>Name: <u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u><br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</h4>
<h4>Student Id: <u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u></h4>

<br/>

<table style="font-size:10pt" width="50%">
<thead>
 <td>Question</td>
 <td>Points</td>
 <td>Score</td>
</thead>
<tr>
 <td>1</td>
 <td>30</td>
 <td></td>
</tr>
<tr>
 <td>2</td>
 <td>2</td>
 <td></td>
</tr>
<tr>
 <td>3</td>
 <td>2</td>
 <td></td>
</tr>
<tr>
 <td>4</td>
 <td>2</td>
 <td></td>
</tr>
<tr>
 <td>5</td>
 <td>2</td>
 <td></td>
</tr>
<tr>
 <td>6</td>
 <td>2</td>
 <td></td>
</tr>
<tr>
 <td>7</td>
 <td>10</td>
 <td></td>
</tr>
<tr>
 <td>8</td>
 <td>15</td>
 <td></td>
</tr>
<tr>
 <td>9</td>
 <td>15</td>
 <td></td>
</tr>
<tr>
 <td>10</td>
 <td>20</td>
 <td></td>
</tr>
<tr>
 <td>Total:</td>
 <td>100</td>
 <td></td>
</tr>
</table>

</center>


(1) (30 points) Mark each question as either True (T) or False (F) by circling either T or F.

   a.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++ is Considered by many to be the first object-oriented programming language.

   b.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FORTRAN was designed as a programming language for business applications.

   c.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**T**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LISP was originally developed for Artificial Intelligence problems.

   d.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A strongly typed programming language is one that detects all type errors at either compile time or run time.

   e.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A non-terminal that occurs on the far left of any production rule is left associative.

   f.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**T**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A function or operator exhibits *subtype polymorphism* if one or more of its parameter types have subtypes.

   g.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A language system involving the classical sequence typically has a step involving the loading of the source code into an interpreter.

   h.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In Ruby like in Java and ML we can add type annotations in order to help the interpreter, as well as other programmers, understand the code.

   i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**T**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EBNF was designed to make context free grammars easier to read. It does not offer any more descriptive power than BNF.

   j.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**T**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Associativity rules only apply to operators of the same precedence.

   k.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**T**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The order of production rules is not significant, i.e., two grammars with identical rules but given in a different order will always define the same language.

   l.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overloading functions and operators can only be done in dynamically type languages because of their greater flexibility.

   m.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An advantage of using an interpreted language is that it runs faster than compile code.

   n.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**T**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subtypes are a superset of the super-type's features.

   o.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In Java, like in ML, the explicit conversion from one type to another is a form of coercion.
<br/><br/><br/><br/><br/>
(2) (2 Points) Give the ML type corresponding to the following set: `{true, false} -> {true, false}`

`fn: bool -> bool`
<br/><br/><br/><br/><br/>
(3) (2 points) Context free grammars are used to capture which aspect of a programming language?

    B. Syntax
<br/><br/><br/>
(4) (2 points) Circle all of the following types that are constructed types:

    B. Ruby String

    E. ML int list
<br/><br/><br/>
(5) (2 points) In Ruby, a method returns?

    B. The value of the evaluation of the expression last evaluated in the method
<br/><br/><br/>
(6) (2 points) Circle all of the following that are Object Oriented Languages.

    A. C#

    C. Java

    E. Perl
<br/><br/><br/>
(7) What is the binding time for each of the following in a C/C++ program? State the binding time as precisely as possible (language-definition time, language-implementation time, compile time, link time, load time, or runtime)

        a. (2 points) The size in memory of a variable of type int.

           Language Implementation Time, since the size of an int is dependent on the
           implementation of the language and the enviroment in which you are programming
           rather than the definition of the language itself.

        b. (2 points) The location in memory of a global static variable.

           Load Time

        c. (2 points) The size in memory of a pointer.

           Language Implementation Time, since a pointer is simply a number representing
           the address where the variable is stored, and the size of that number is
           dependent on the implementation of C/C++ you are using.

        d. (2 points) The values(s) assigned to a variable.

           Runtime, the value can only be known when the program is executed.

        e. (2 points) The code for the `printf` function.

           Link Time, as this is the point in which the code for the `printf` function will
           be found and bound to your program, the headers which point to `printf` will
           indicate the availability of the function but it's actual code will not be
           available until linking occurs.
<br/>
(8) Answer these questions about the following grammar. The starting symbol is `<re>`

```
   <do> ::= <me> | <do> % <me>
   <re> ::= <do> & <re> | <do>
   <me> ::= ( <re> ) | a | b
```

        a. (2 points) Which operator has higher precedence?

            %

        b. (2 points) What is the associativity of the `%` operator?

            Left-associative

        c. (2 points) Does this grammar describe a finite or infinite language?

            Infinite, since the grammar is defined with the last rule recursing on the start rule, providing for the ability to construct an infinite sequence of strings.

        d. (2 points) Is this grammar ambiguous?

            No, there are no rules defined such that the same non-terminal occurs within the rule more than once.

        e. (4 points) Rewrite this grammar using EBNF, considering the version of EBNF
        provided in the book which adds only the grouping symbols `[ ]`, `{ }`, and
        `( )`.

            <do> ::= [<do> %] <me>
            <re> ::= <do> [& <re>]
            <me> ::= '(' <re> ')' | a | b

            <do> ::= <me> { % <me>}
            <re> ::= <do> [& <re>]
            <me> ::= '(' <re> ')' | a | b
            Note: <prodA> ::= <prodB> {op <prodB>} form is left-associative

            <do> ::= [<do> %] <me>
            <re> ::= <do> {& <do>}
            <me> ::= '(' <re> ')' | a | b
            Note: <prodA> ::= <prodB> {op <prodB>} form is right-associative

            Any of these 3 solutions would have been fully accepted

        f. (3 points) Draw a parse tree to explain the string: `b & a % (a & b)`


                                  <re>
                                    |
                  ------------------------------------
                  |                 |                |
                 <do>               &               <re>
                  |                                  |
                 <me>                               <do>
                  |                                  |
                  |                     ----------------------------
                  |                     |            |             |
                  b                    <do>          %            <me>
                                        |                          |
                                        |                 -------------------
                                        |                 |        |        |
                                       <me>               (       <re>      )
                                        |                          |
                                        |                    -------------
                                        |                    |     |     |
                                        a                   <do>   &    <re>
                                                             |           |
                                                            <me>        <do>
                                                             |           |
                                                             a          <me>
                                                                         |
                                                                         b

(9) Suppose there are three variables X, Y, and Z with these types:
```
   X: integer that is divisible by 3
   Y: integer that is divisible by 12
   Z: integer
```

For each of the following assignments, knowing nothing about the values of the variables except their types, answer whether a language system can tell before running the program whether the assignment is safe? Answer Yes or No and explain why.

        a. (5 points) `X := Y`

           Yes, since the set of integers divisible by 12, Y, is a subset of the integers divisible by 3, X.

        b. (5 points) `X := X + Y`

           Yes, since all members of Y are also members of X and thus any addition of a member of X with a member of Y yields a member of X.

        c. (5 points) `X := Z`

           No, since Z is the super set of X not all members of Z are members of X, thus without knowing the exact values we cannot guarantee the safety of this assignment.
<br/>
(10) Consider an unknown language with a left-associative - operator that is overloaded to have the following types: `int * real -> real`, `int * int -> int`, `real*int -> real`, and `real*real -> real`. Suppose the variable `i` has type `int` and the variable `r` has type `real`. For each `-` operator in each of the following expressions, say which type of `-` is used:

        a. (5 points) `r - i`

            r - i: real * int -> real

        b. (5 points) `r - i - r`

            r - i: real * int -> real
            i - r: real * real -> real

        c. (5 points) `r - (i - r)`

            (i - r): int * real -> real
            r - (): real * real -> real

        d. (5 points) `i - r - i - (i - r)`

            (i - r): int * real -> real
            i - r: int * real -> real
            r - i: real * int -> real
            i - (): real * real -> real

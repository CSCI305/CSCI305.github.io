<center>

<hr>
<h1>Montana State University</h1>

<h2>CSCI 305 - Programming Languages</h2>

<h3>Midterm Exam</h3>

<h3>SPRING, 2018</h3>

<hr>

<h4>Name: <u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u><br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</h4>
<h4>Student Id: <u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</u></h4>

<br/>

<table style="font-size:10pt" width="50%">
<thead>
 <td>Question</td>
 <td>Points</td>
 <td>Score</td>
</thead>
<tr>
 <td>1</td>
 <td>30</td>
 <td></td>
</tr>
<tr>
 <td>2</td>
 <td>2</td>
 <td></td>
</tr>
<tr>
 <td>3</td>
 <td>2</td>
 <td></td>
</tr>
<tr>
 <td>4</td>
 <td>2</td>
 <td></td>
</tr>
<tr>
 <td>5</td>
 <td>2</td>
 <td></td>
</tr>
<tr>
 <td>6</td>
 <td>2</td>
 <td></td>
</tr>
<tr>
 <td>7</td>
 <td>10</td>
 <td></td>
</tr>
<tr>
 <td>8</td>
 <td>15</td>
 <td></td>
</tr>
<tr>
 <td>9</td>
 <td>15</td>
 <td></td>
</tr>
<tr>
 <td>10</td>
 <td>20</td>
 <td></td>
</tr>
<tr>
 <td>Total:</td>
 <td>100</td>
 <td></td>
</tr>
</table>

</center>


(1) (30 points) Mark each question as either True (T) or False (F) by circling either T or F.

   a.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++ is Considered by many to be the first object-oriented programming language.

   b.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FORTRAN was designed as a programming language for business applications.

   c.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**T**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LISP was originally developed for Artificial Intelligence problems.

   d.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A strongly typed programming language is one that detects all type errors at either compile time or run time.

   e.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A non-terminal that occurs on the far left of any production rule is left associative.

   f.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**T**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A function or operator exhibits *subtype polymorphism* if one or more of its parameter types have subtypes.

   g.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A language system involving the classical sequence typically has a step involving the loading of the source code into an interpreter.

   h.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In ruby like in Java and ML we can add type annotations in order to help the interpreter, as well as other programmers, understand the code.

   i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**T**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EBNF was designed to make context free grammars easier to read. It does not offer any more descriptive power than BNF.

   j.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**T**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Associativity rules only apply to operators of the same precedence.

   k.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**T**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The order of production rules is not significant, i.e., two grammars with identical rules but given in a different order will always define the same language.

   l.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overloading functions and operators can only be done in dynamically type languages because of their greater flexibility.

   m.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An advantage of using an interpreted language is that it runs faster than compile code.

   n.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**T**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subtypes are a superset of the super-type's features.

   o.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**F**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In Java, like in ML, the explicit conversion from one type to another is a form of coercion.

<br/>
(2) (2 Points) Give the ML type corresponding to the following set: `{true, false} -> {true, false}`

    `bool -> bool`

<br/>
(3) (2 points) Context free grammars are used to capture which aspect of a programming language?

    B. Syntax

<br/>
(4) (2 points) Circle all of the following types that are constructed types:

    B. Ruby String

    E. ML int list

<br/>
(5) (2 points) In Ruby, a method returns?

    B. The value of the evaluation of the expression last evaluated in the method

<br/>
(6) (2 points) Circle all of the following that are Object Oriented Languages.

    A. C\#

    C. Java

    E. Perl

<br/>
(7) What is the binding time for each of the following in a C/C++ program? State the binding time as precisely as possible (language-definition time, language-implementation time, compile time, link time, load time, or runtime)

        a. (2 points) The size in memory of a variable of type int.

           Language Implementation Time

        b. (2 points) The location in memory of a global static variable.

           Load Time

        c. (2 points) The size in memory of a pointer.

           Language Implementation Time

        d. (2 points) The values(s) assigned to a variable.

           Runtime

        e. (2 points) The code for the `printf` function.

           Link Time

<br/>
(8) Answer these questions about the following grammar. The starting symbol is `<re>`

```
   <do> ::= <me> | <do> % <me>
   <re> ::= <do> & <re> | <do>
   <me> ::= ( <re> ) | a | b
```

        a. (2 points) Which operator has higher precedence?

            %

        b. (2 points) What is the associativity of the `%` operator?

            left-associative

        c. (2 points) Does this grammar describe a finite or infinite language?

            infinite

        d. (2 points) Is this grammar ambiguous?

            No

        e. (4 points) Rewrite this grammar using EBNF, considering the version of EBNF
        provided in the book which adds only the grouping symbols `[ ]`, `{ }`, and
        `( )`.

            <re> ::= <do> [& <re>]
            <do> ::= [<do> %] <me>
            <me> ::= ( <re> ) | a | b

        f. (3 points) Draw a parse tree to explain the string: `b & a % (a & b)`
                              <re>
                                |
                    -------------------------
                    |           |            |
                   <do>         &           <re>
                    |                        |
                   <me>                     <do>
                    |                        |
                    b               --------------------
                                    |        |         |
                                   <do>      %        <me>
                                    |                  |
                                   <me>               <re>
                                    |                  |
                                    a           ----------------
                                                |      |       |
                                                (     <re>     )
                                                       |
                                                ----------------
                                                |      |       |
                                               <do>    &      <re>
                                                |              |
                                               <me>           <do>
                                                |              |
                                                a             <me>
                                                               |
                                                               b
<br/>

(9) Suppose there are three variables X, Y, and Z with these types:
```
   X: integer that is divisible by 3
   Y: integer that is divisible by 12
   Z: integer
```

For each of the following assignments, knowing nothing about the values of the variables except their types, answer whether a language system can tell before running the program whether the assignment is safe? Answer Yes or No and explain why.

        a. (5 points) `X := Y`

          Yes, as Y is a proper subset of X

        b. (5 points) `X := X + Y`

          Yes, as (X + Y) is a proper subset of X

        c. (5 points) `X := Z`

          No, as X is a subset of Z
          
<br/>
(10) Consider an unknown language with a left-associative - operator that is overloaded to have the following types: `int * real -> real`, `int * int -> int`, `real*int -> real`, and `real*real -> real`. Suppose the variable `i` has type `int` and the variable `r` has type `real`. For each `-` operator in each of the following expressions, say which type of `-` is used:

        a. (5 points) `r - i`

           r - i: real * int -> real

        b. (5 points) `r - i - r`

           r - i: real * int -> real
           i - r: real * real -> real

        c. (5 points) `r - (i - r)`

           i - r: int * real -> real
           r - (): real * real -> real

        d. (5 points) `i - r - i - (i - r)`

           (i - r): int * real -> real
           i - r: int * real -> real
           r - i: real * int -> real
           i - (): real * real -> real
